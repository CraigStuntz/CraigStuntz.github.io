<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="Craig Stuntz's personal website about programming languages, type theory, DIY synthesizers, compilers, and math.">
        <title>A Very Gentle Introduction to Type Checking, Chapter 1.1:  - Craig Stuntz</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css">
        <link rel="alternate" type="application/rss+xml" title="Craig Stuntz's blog" href="../feed.xml">
        <link rel="alternate" type="application/atom+xml" title="Craig Stuntz's blog" href="../atom.xml">
        <link rel="me" href="https://discuss.systems/@CraigStuntz">
        <!-- KaTeX -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
            <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Craig Stuntz</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../presentations.html">Presentations</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            
                <h3 class="series">
                    A Very Gentle Introduction to Type Checking,
                        1.1
                    
                </h3>
            
            
                <h1 class="chapterName">
                    The Untyped Lambda Calculus (and Friends!)
                </h1>
            
            <div class="info">
    Posted on June 15, 2024
    
</div>

<div class="toc">
<ul>
<li>Introduction: Type checkin’</li>
<li>1: The Untyped Lambda Calculus
<ul>
<li>1.1: What Even Is The Untyped Lambda Calculus (Etc.)?</li>
</ul></li>
</ul>
</div>
<p>Today we will be learning about the untyped lambda calculus (and friends!). As
the name suggests, building a type checker for the untyped lambda calculus would
be rather useless, as there is only one type in the language and therefore any
syntactically valid program would type check: there are no type errors, only
syntax errors. Instead we will use this language to learn about
<strong>normalization by evaluation</strong>, which will be used when we build a type checker for
the simply typed lambda calculus (part 2) and <em>necessary</em> when we build a
type checker for Tartlet (part 3).</p>
<p>This will be a long post because there are a lot of concepts
introduced here! Feel free to skip the sections on any concepts you are already
comfortable with! Heck, skip the whole thing if you’d rather just dive into the
code.</p>
<p>My plan is that in each section of this series I’m going to give enough
information that a programmer can understand a section of David’s
tutorial. My goal for this post is to get you through the title and the first
few paragraphs.</p>
<h2 id="the-plan-for-learning">The Plan for Learning</h2>
<p>A type checker needs to look an expression and find its type and then evaluate
whether that type is compatible (equivalent) with the type it expecting in a
certain situation. For example, if a function’s argument is typed <code>Int</code> then it
must look at the expression given for the argument at the point where that function is invoked
and determine if the type of that expression is equivalent to <code>Int</code>. Because this
expression could be a literal <code>Int</code>, a variable of type <code>Int</code>, the result of another
function which returns an <code>Int</code>, or some supertype of <code>Int</code> allowed by the programming language, this is
more complicated in practice than it might seem and it will be easier if we can
first <strong>normalize</strong> (simplify) the expression.</p>
<p>Some of the concepts we will discuss in this section are both rather difficult
to mentally evaluate and not necessary to understand when building a type
checker. (I’m looking at you, Church numerals.) One possible approach is to skim these sections, don’t
spend too much time trying to wrap your head around them, and just accept that the
expected values we will use in unit tests are correct. I hope to give you enough
information to distinguish between correct and incorrect outcomes even if you
don’t mentally evaluate the Church numerals we will program in the untyped lambda
calculus, which is rather challenging. This is a valid way to learn as building
a type checker
depends on understanding normalization but does not depend on understanding
Church numerals.</p>
<p>Another thing that you could do is spend time deeply understanding each section
before moving on. That’s a valid choice if you have the time! The best part is
that it’s <em>your</em> choice; either way should work fine insofar as getting you to
the part where we actually build a type checker, which will come in the next
section.</p>
<p>In this post we will start learning about normalizing expressions by evaluation,
which is a really, really important concept that you must understand in order to
complete the tutorial. David teaches this by building a normailzation system for
the untyped lambda calculus, and uses adding two Church encoded numbers together
as an example. It’s less important that you understand every detail of this, but
you should at least grasp the broad outlines of what we’re going to do.</p>
<h2 id="the-annotated-checking-dependent-types-with-normalization-by-evaluation">The Annotated “Checking Dependent Types with Normalization by Evaluation”</h2>
<p>Throughout this series, I will quote from David’s tutorial, which I will put
in a yellow box, like this:</p>
<div class="highlight">
<p><strong>Checking Dependent Types with Normalization by Evaluation</strong></p>
<p>To implement dependent types, we need to be able to determine when two types
are the same. In simple type systems, this process is a fairly straightforward
structural equality check, but as the expressive power of a type system
increases, this equality check becomes more difficult.</p>
</div>
<figure class="inlineRight">
<div class="sourceCode" id="cb1"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>implicit <span class="kw">enum</span> Type<span class="op">:</span> <span class="dt">Equatable</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> int</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> boolean</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> list<span class="op">(</span>Type<span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">t1</span> <span class="op">=</span> Type<span class="op">.</span>int</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">t2</span> <span class="op">=</span> Type<span class="op">.</span>int</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>assert<span class="op">(</span>t1 <span class="op">==</span> t2<span class="op">)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">t3</span> <span class="op">=</span> Type<span class="op">.</span>list<span class="op">(</span>t1<span class="op">)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">t4</span> <span class="op">=</span> Type<span class="op">.</span>list<span class="op">(</span>t2<span class="op">)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>assert<span class="op">(</span>t3 <span class="op">==</span> t4<span class="op">)</span></span></code></pre></div>
<figcaption>
Structural equality; different instances are equal when they contain
the same values
</figcaption>
</figure>
<p>As noted earlier, if the only types your programming language contained were
<code>Int</code> and <code>Boolean</code> then this would indeed be very easy. <code>Int == Int</code> and
<code>Int != Boolean</code> and we’re finished. However, even in the case of the “simple”
language we’ll be type checking we want to handle functions, recursion, type
annotations, etc., which requires a bit more care.</p>
<p>A “fairly straightforward structural equality check” means that we might need to
do a comparison just slightly more complicated than <code>Int == Int</code> (for example,
we might need to check equality on a sum type, which in Swift is known as
<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations/#Associated-Values">an <code>enum</code> with associated values</a>), but we can still do this quite easily. In
Swift you just add <code>: Equatable</code> to the <code>enum</code> definition and the compiler will
generate the necessary code for you to allow an <code>==</code> comparsion.</p>
<p>However, more complicated type systems (e.g., Swift includes subtyping and
<a href="http://www.lithium3141.com/blog/2014/12/14/learning-swift-convertibles/">convertibles</a>)
will require an analysis which is a bit more
complicated than just a simple structural equality check. This can be fairly
subtle.</p>
<h2 id="what-are-dependent-types">What Are Dependent Types?</h2>
<p>It will be important to understand what dependent types are when we start
building a type checker for Tartlet, which is the third and final part of the
tutorial. Fell free to skip this section and come back to it before you start
part 3.</p>
<div class="highlight">
<p>In particular, when types can contain programs, we need to be able to run
these programs and check whether their outputs are the same.</p>
</div>
<p>“…when types can contain programs” refers to dependent types. This is sort of
starting at the end; there will be a lot of material to cover before we get to
a dependently typed language. But it’s worth knowing what dependent types are.</p>
<p>Depending upon your point of view, dependent types are:</p>
<ul>
<li>The sort of types used by languages such as <a href="https://www.idris-lang.org/">Idris</a>,
<a href="https://agda.readthedocs.io/en/latest/index.html">Agda</a>, and <a href="https://lean-lang.org/">Lean</a>.</li>
<li>A type system where types can include a value. The classic example is that
a list of length 0 is a different type than a list of length 1 — the length
of the list is a value and is part of the type.</li>
<li>A programming language where there is no hard line between types and regular
values; new types can be computed in the same way that new values can.</li>
<li>A Turing complete type system, where arbitrary computations can be performed
in the types, instead of just in the normal expressions.</li>
</ul>
<p>All of these statements are correct.</p>
<p>The sort of type checker you had in mind to implement might not require checking
dependent types; if you’re going to write a type checker for Swift or Java, you
won’t need them. (You will, however, need to deal with subtyping, which can be
challenging.) The general technique of bidirectional type checking will
still be useful even if dependent types aren’t included in the programming
language you’re checking.</p>
<p>Speaking of which…</p>
<h2 id="what-is-bidirectional-type-checking">What Is Bidirectional Type Checking?</h2>
<p>Understanding bidirectional typechecking is whole point of the tutorial!
However, we won’t actually work on a bidirectional type checker until part 2.</p>
<div class="highlight">
<p>Normalization by evaluation is one way of performing this sameness check,
while bidirectional type checking guides the invocation of the checks.</p>
</div>
<p>In the bad old days of statically typed programming languages, it was common to
have languages where all types were checked, and none were inferred. (Think early
versions of Java or C#.) This became painful and redundant, and programmers
wondered if there was a better way. In fact there <em>was</em> a better way, as the
programming language ML demonstrated in, um, 1973. It just took the rest of the
world a while to catch up.</p>
<p>In many cases it is possible to <strong>infer</strong> types instead of checking them. This
can be taken to an extreme: In some programming languages such as Haskell or ML
there is not a strict requirement to ever declare a type. However, most
programmers have found that not ever using any type annotations makes
programming errors very difficult to diagnose, and so they will typically use a
style guide that requires use of type annotations on function declarations and
other places. Other programming languages, such as Swift and the current version
of C#, allow type inference in some places but <em>require</em> it on named function
declarations.</p>
<p>Bidirectional type checking combines type checking and type synthesis
(inference) in a principled way. Sometimes, given an expression we can
synthesize/infer its type. Other times we know what type we are expecting and
need to confirm (check) that the expression has an equivalent type.
Bidirectional type checking tells us whether we should be using type synthesis
or type checking in any given context.</p>
<p>For example, if we enounter a variable at a use site (in other words, after it
is declared), we can synthesize the type by looking up
the variable in the context, or list of variables in scope. In other cases, we
must check the type against some existing type, for example if there is a
function call in code then we must check that we are in fact calling a reference
of a function type (and not, say, an integer). Bidirectional type checking makes
it clear whether we should use synthesis or checking in any situation we might
encounter in code. By doing so, it is a guideline for how to write
a type checker which is sufficiently powerful to implement most features needed
by contemporary programming languages, including some with advanced type
systems.</p>
<h2 id="what-is-normalization">What Is Normalization?</h2>
<p>Understanding normalization is the goal of part 1. First I will explain it
conceptually; later we will write some code and see how it works in practice.</p>
<p>We are going to learn how to take an expression and
convert it to a “simpler” form, called the <strong>normal form</strong>, in a process called
<strong>normalization</strong>. The reason we need to do this is we have to decide if the type
of an expression is equivalent to the type that we are expecting. This is easier
if the expression is in the simplest possible form.</p>
<h3 id="a-very-simple-example">A Very Simple Example</h3>
<p>That’s a little abstract, so let’s look at an example from Swift:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">zero</span><span class="op">:</span> Int <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">increment</span><span class="op">(</span><span class="va">n</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span> -&gt; <span class="fu">Int</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">one</span> <span class="op">=</span> increment<span class="op">(</span>n<span class="op">:</span> zero<span class="op">)</span></span></code></pre></div>
<p>So far, so good, but of course we could have written <code>one</code> as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">one</span><span class="op">:</span> Int <span class="op">=</span> <span class="dv">1</span> <span class="co">// because increment(n: zero) == 1</span></span></code></pre></div>
<p>You might prefer one version of the <em>source code,</em> but in fact both versions are
the same <em>value</em> in the end. We call the second version, with the literal <code>1</code>, the
<strong>normalized</strong> version because it is “less complicated” than the version with
the function call to <code>increment</code>. We will formalize the definition of “less
complicated” in the near future.</p>
<h3 id="what-is-the-point-of-normalization">What Is the Point of Normalization?</h3>
<p>When writing a type checker it is easier to look at simpler forms, and in this
example the literal value <code>1</code> is simpler than the result of a function call.</p>
<p>When you are type checking a call to some function, you need to decide if it’s
legal to call that function with a given argument value. With the untyped lambda
calculus, which we will meet below, the answer is clearly “yes” because there
is only one type, so there is no need to type check at all. So why will we be
dealing with the untyped lambda calculus in a type checking tutorial at all?
Well, peeking ahead a little, we will want to look two types (say, the
argument type required by a function and the type of the expression we’re
attempting to pass as that argument) and decide if they’re “equivalent.” We will
do this by normalizing an expression
first and then doing an equivalence comparison on it, so first we must learn to
normalize!</p>
<h3 id="a-slightly-more-complicated-example">A Slightly More Complicated Example</h3>
<p>When calling <code>increment</code> we want to pass a value, which we store in the variable <code>zero</code>
and pass as the <code>n</code> argument. <code>zero</code> is a variable of type <code>Int</code> and in fact contains an
instance of type <code>Int</code>, so the type check should be successful.</p>
<p>Should this type check?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">three</span> <span class="op">=</span> increment<span class="op">(</span>n<span class="op">:</span> increment<span class="op">(</span>n<span class="op">:</span> increment<span class="op">(</span>n<span class="op">:</span> zero<span class="op">)))</span></span></code></pre></div>
<p>If you’ve been programming for a while I think you’ll agree that the answer is
“yes,” but it’s not quite so simple for the type checker to answer. In this case
we must know that we are allowed to pass a function call, with all required
arguments, in a place that requires a value with the same type as the function
call’s result. The type checker must also check the entire stack of function
calls in order to make sure everything is correct. Even in this simple example
that’s not a trivial task, and we will be considering far more complicated cases
before the end of this series.</p>
<p>Happily, as with most things in compiler design, there are “recipes” you can
follow to solve such problems reliably!</p>
<h3 id="ok-but-what-is-normalization-by-evaluation">Ok, But What Is ‘Normalization By Evaluation’</h3>
<p>Evaluation means just what you think it does, if you’ve studied compilers or
have used a language with an <code>eval</code> function. We will interpret the syntax of
the code and by doing so reduce it to a “simpler” form. For example, references
to a variable will be substituted with the value of that variable.</p>
<p>If you evaluate the expression above, you get a normalized form, which is:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">three</span><span class="op">:</span> Int <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
<p>We normally think of such evaluations as happening at runtime, but this is not
strictly correct. There is no reason the example given can’t be evaluated at
compile time and in fact in most languages the optimizer will do exactly that
for such simple arithmetic. We can also perform such evaluation <em>before</em>
optimization when needed.</p>
<p>It will be much easier to do type compatibility checks when all of our code is
in normalized form!</p>
<p>I’m not going to discuss this much more for now because we will cover it in
great detail in the near future, but I just want to put into your mind the idea
that evaluating an expression will result in it eventually becoming normalized,
because that is in fact true.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>We can’t always evaluate a function at compile time like this; some function
results depend on values which are unknown until runtime. But we can do it often
enough to be helpful, and in particular we can do it when type checking dependent types.</p>
<h2 id="what-even-is-the-untyped-lambda-calculus">What Even Is the Untyped Lambda Calculus?</h2>
<div class="highlight">
<p><em>1 Evaluating Untyped λ-Calculus</em></p>
<p>Let’s start with an evaluator for the untyped λ-calculus.</p>
</div>
<p>In order to demonstrate normalization by evaluation, we will begin with
something called “the untyped lambda calculus.”
Don’t be put off by the Greek letters or a mention of “calculus”; we will not be
computing integrals here! It’s worth knowing just a little bit about the untyped
lambda calculus so that you recognize what is going on in the examples which we
will use, but if you find yourself puzzling out individual derivations, just
know that it’s not really necessary to understand the type checker which we are
building.</p>
<p>You can look at the untyped lambda calculus as a very tiny programming language, or you
can look at it as an alternate model of computation. Both are correct views. There is only one data
type, which is an anonymous function taking a single argument and returning a
single value. The type of this argument and returned value are, naturally,
anonymous functions taking a single argument and returning a single value.
<em>There are no other types.</em></p>
<p>Sometimes people say that programming languages would be easier to learn if they
had a simple core with fewer features. That might be right in some cases, but
the untyped lambda calculus shows that there is a bottom bound to this idea.
There is basically <em>one</em> feature in the whole language, and it’s quite difficult
to write any meaningful programs in. However, it’s quite simple to write an
expression evaluator for it due to its simplicity, and as that is what we are
aiming to do it is a good choice for our purposes. Still, this section is a bit
complicated if it’s your first exposure to the untyped lambda calculus!<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h3 id="the-simplest-value-in-the-untyped-lambda-calculus">The Simplest Value In the Untyped Lambda Calculus</h3>
<p>Let’s consider the simplest possible value in the untyped lambda caculus, the
identity function. It just returns the value of its argument. Values in the
untyped lambda calculus start with the Greek lower-case lambda, <code>λ</code>, then they
have an arugment name, by convention a single lower-case character, and then a
dot (<code>.</code>), followed by the body of the function. So the identity function looks
like this:</p>
<pre><code>λx.x</code></pre>
<p>Think: “An anonymous function that when called with some value <code>x</code> returns that value <code>x</code>.
(In Swift it would look like <code>{ x in x }</code>; in JavaScript it would look like
<code>x =&gt; x</code>).</p>
<p>It’s hard to even consider this in terms of other programming languages, which
have, you know, integers, and booleans and stuff, because the untyped lambda
calculus very much does not have types for integers and booleans and stuff.
However, you can use these functions to perform computations which are the same
as in languages which <em>do</em> have those features.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div class="highlight">
<p>Writing an evaluator requires the following steps:</p>
<ul>
<li>Identify the values that are to be the result of evaluation</li>
<li>Figure out which expressions become values immediately, and which require
computation</li>
<li>Implement structs for the values, and use procedures for computation</li>
</ul>
<p>In this case, for the untyped λ-calculus, the only values available are
closures, and computation occurs when a closure is applied to another value.</p>
</div>
<p>Writing an evaluator means we will be interpreting the untyped lambda calculus.
If you’re into compilers this should be familiar territory. We will be starting
with the code we are evaluating in the untyped lambda calculus “already parsed”
into an abstract syntax tree (AST); that is, the input to our evaluator will be
AST expressions instead of strings. But we require additional types
to hold values as we evaluate that AST.</p>
<p>You may have encountered the term
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)"><strong>closure</strong></a> before,
but it’s a combination of a function and an environment which may include both
bound variables (arguments to the function) and free variables (variables which
are defined externally to the function’s body).</p>
<p>“when a closure is applied to another value” means when the closure is invoked
using another value as an argument.</p>
<h2 id="what-even-is-a-natural-number">What Even Is a Natural Number?</h2>
<p>If you want to do something more complicated in your program in the untyped
lambda calculus, like add two numbers together, then you have to stop and think
about how you’re going to represent numbers in a programming language which
doesn’t have them.</p>
<p>The type of number that we’re going to use is a <strong>natural number</strong>, and by this
we mean a number which is in the set <span class="math inline">{0, 1, 2, ..., ∞}</span>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> However, we
are going to have to think about how to represent these using anonymous
functions!</p>
<p>Swift doesn’t have a type like this. It has <code>UInt64</code>, but there are obviously
values too large to store in a <code>UInt64</code>. It turns out that this really matters,
because the type of <code>increment</code> above is actually a bit more complicated than “Int”.
It actually means “an <code>Int</code> or perhaps it might throw an exception due to a numeric
overflow.”</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">➜</span> swift repl  </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Welcome</span> to Apple Swift version 5.10 <span class="er">(</span><span class="ex">swiftlang-5.10.0.13</span> clang-1500.3.9.4<span class="kw">)</span><span class="bu">.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Type</span> :help for assistance.</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span><span class="op">&gt;</span> func <span class="ex">increment</span><span class="er">(</span><span class="ex">n:</span> Int<span class="kw">)</span> <span class="ex">-</span><span class="op">&gt;</span> Int { return n + 1 }</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="dv">2</span><span class="op">&gt;</span> increment<span class="kw">(</span><span class="ex">n:</span> Int.max<span class="kw">)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Execution</span> interrupted. Enter code to recover and continue.</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Enter</span> LLDB commands to investigate <span class="er">(</span><span class="bu">type</span> :help for assistance.<span class="kw">)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="dv">3</span><span class="op">&gt;</span>  </span></code></pre></div>
<p>You might think I’m being overly picky here, but a type checker must understand
every possible case for the types in use. Does this mean that Swift is unsound?
Not really, this notion of “or may throw a numeric overflow exception” is built
into the language, and makes the language design and implementation somewhat
more difficult. Real languages have complicated types! Again, we will be
starting with a simpler language.</p>
<h2 id="what-even-is-a-church-numeral">What Even Is a Church Numeral?</h2>
<p>You do not need to understand Church numerals to complete the tutorial.</p>
<p>The type checker must solve a problem which is very similar to the optimizer: Is
it safe to replace one expression with a different expression, in every possible
case? As we have seen with <code>increment</code> above, this can be a pertty subtle question,
with edge cases which are not obvious from looking at source code.</p>
<p>How can we
be sure that saying that a number is “a natural number” means that it can be
used <em>anywhere</em> a program expects a natural number to be used? Also, how can we
represent natural numbers in a language which has functions as its sole data
type?</p>
<p>It would help if instead of considering, well, <span class="math inline">∞</span> cases, we could cut that
list down a bit. And for the type of natural numbers, we can in fact cut it down
to only two cases:</p>
<ul>
<li><code>zero</code></li>
<li><code>add1 n</code></li>
</ul>
<p><code>add1</code> means “given some value <code>n</code> which is certainly a natural number, the next
largest value, <span class="math inline"><em>n</em> + 1</span>.”<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>So (in Swift) we can literally have a data type like:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>indirect <span class="kw">enum</span> Nat <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> zero</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> add1<span class="op">(</span>Nat<span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And now Swift has a “natural numbers” data type! You can store any natural number in
this type, although you may eventually run out of memory.</p>
<h3 id="church-numerals-in-the-untyped-lambda-calculus">Church Numerals In the Untyped Lambda Calculus</h3>
<p>But we’re not here to learn Swift right now, and we aren’t even trying to
produce a tutorial for the untyped lambda calculus. Instead we just need enough
exposure to it to know if our evaluator is working correctly.</p>
<p>We can represent the natural numbers in the untyped lambda calculus as follows:<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<pre><code>zero = λf.λx.x
add1 = λn.λf.λx.f (n f x)</code></pre>
<p>This implies that, for example, <code>one</code> (a function representhing the natural
number <code>1</code>) is:</p>
<pre><code>one = add1 zero 
    = λf.λx.f x</code></pre>
<p>We will see the full derivation below.</p>
<p>There are more examples; hopefully you can start to see a pattern here:</p>
<pre><code>zero  = λf.λx.x
one   = λf.λx.f x
two   = λf.λx.f(f x)
three = λf.λx.f(f(f x))
four  = λf.λx.f(f(f(f x)))
five  = λf.λx.f(f(f(f(f x))))</code></pre>
<p>Here is the worked out version of <code>add1 zero</code>. (Don’t worry if you can’t follow
this derivation; we have computers to do this for us):</p>
<pre><code>one = add1 zero                                   because 1 = 1 + 0
    = (λn.λf.λx.f (n f x)) (λf.λx.x)              substitute defintions of add1 and zero
    = λf.λx.f λf.λx.x f x                         substitute λf.λx.x for argument n
    = λf.λx.f λf.f x                              because (λx.x) f = f
    = λf.λx.f x                                   because (λf.f) x = x</code></pre>
<p>This way of storing natural numbers is sometimes called a
“<a href="https://en.wikipedia.org/wiki/Church_encoding#Church_numerals">Church numeral</a>.”
And this simplification of <code>add1 zero</code> into <code>λf.λx.f x</code> is exactly the sort of
evaluation we will be performing as part of “normalization by evaluation.”
Clearly it’s a pain to do this by hand, so we will be writing an expression
evaluator to do it for us!</p>
<p>The way to think about Church numerals as expressed in the functions above is
that when invoked they run a function, call it <code>f</code>, as many times as the
numeral. So <code>zero</code>, above, <em>never evaluates</em> <code>f</code> and so runs it <em>zero</em> times.
But <code>one</code> must evaluates <code>f</code> <em>once</em> when invoked. And so on for larger numbers.</p>
<p>Another handy function is <code>plus</code>:</p>
<pre><code>plus = λj.λk.λf.λx.(j f) (k f x)</code></pre>
<p>And in particular, we will be evaluating this specific expression in the
tutorial:</p>
<pre><code>plus two three = five</code></pre>
<p>That is to say:</p>
<pre><code>plus (λf.λx.f(f x)) (λf.λx.f(f(f x))) = λf.λx.f(f(f(f(f x))))</code></pre>
<p>I am not going to try to derive this by hand and I don’t think there’s much to
be gained by doing so unless you intend to study the untyped lambda calculus,
which isn’t really the point of what we are doing here. Our goal is to build a
type checker, and this is just a step along the way. If we can take the
expression <code>plus two three</code> and evaluate it and get <code>λf.λx.f(f(f(f(f x))))</code> from
our evaluator then we know that it is working and produces an expression in normal
(simplest) form.</p>
<h3 id="why-why-why-for-the-love-of-church-why">Why, Why, Why for the Love of Church, Why?</h3>
<p>Of course, representing a number like <code>1000</code> would seem to be a little bit
involved given such an encoding, but on the positive side we have made such
values much easier to type check: There are only two cases! (<code>zero</code> and <code>add1</code>.)</p>
<p>What the point of all this is? Why not just
use better known data types from better known languages? We could do that, but
the implementation would be far more complicated, as “real” programming
languages tend to have many more special cases and exceptions in their
semantics (for example, numeric exceptions, implicit conversions, function
overloading, etc.). The languages and data types used in this tutorial are
explicitly designed to be (extremely!) minimal and easy to reason about. For example, with a
Church encoded natural number, if you can prove a statement about only two
cases, <code>zero</code> and <code>add1(n)</code> where <code>n</code> is any natural number, then you have
proven the statement about <em>every</em> natural number, all <span class="math inline">∞</span> of them!</p>
<h2 id="abstract-syntax-trees">Abstract Syntax Trees</h2>
<p>We will not be doing any parsing in this series. This makes some things easier
and some things more complicated. On the plus side, there’s no need to write a
parser! On the less convenient side, when we want to deal with source code in
our programs we must write it in a “pre-parsed” state, which is an abstract
syntax tree (AST).</p>
<p>For example, in the untyped lambda calculus we might write the identity function
as:</p>
<pre><code>λx.x</code></pre>
<p>However this line of code written as an abstract syntax tree in Swift would be:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>Expr<span class="op">.</span>lambda<span class="op">(</span><span class="st">&quot;x&quot;</span><span class="op">,</span> <span class="op">.</span>variable<span class="op">(</span><span class="st">&quot;x&quot;</span><span class="op">))</span></span></code></pre></div>
<p>…which is somewhat more challenging to mentally parse. Because of this I will
usually put the “unparsed” (literal source code version) in comments near the
“parsed” (AST) version, like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode swift"><code class="sourceCode swift"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">//  id = λx.x</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">id</span> <span class="op">=</span> Expr<span class="op">.</span>lambda<span class="op">(</span><span class="st">&quot;x&quot;</span><span class="op">,</span> <span class="op">.</span>variable<span class="op">(</span><span class="st">&quot;x&quot;</span><span class="op">))</span></span></code></pre></div>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This is somewhat complicated to prove; see for example
<a href="https://tidsskrift.dk/brics/article/view/20473">Normalization by Evaluation with Typed Abstract Syntax</a>
for more information.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>One might fairly ask why David picked the untyped lambda calculus as
an example. Nothing in the tutorial depends on its use; it’s just a
simple example here. The untyped lambda calculus is important in
theoretical computer science and so one can presume that folks coming
to the tutorial from a TCS background will be familiar with it
already. This is perhaps less true when people approach the tutorial
from a “practitioner”/commercial programmer background. However, the
untyped lambda calculus does have at least one thing going for it,
which is that it’s very simple to evaluate. We will be doing that
very soon!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>It turns out that the untyped lambda calculus is
<a href="https://www.youtube.com/watch?v=RPQD7-AOjMI">Turing complete</a>,
and can compute literally anything that any other programming
language can express. However, we won’t be making use of this
fact in this series.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Mathematicians, somewhat inconveniently,
<a href="https://mathworld.wolfram.com/NaturalNumber.html">use two different definitions of “natural numbers,”</a> namely <span class="math inline">{0, 1, 2, ..., ∞}</span>
and <span class="math inline">{1, 2, 3, ..., ∞}</span>. We (and, indeed, nearly all
computer scientists) will use only the former.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>It’s more common to call <code>add1</code> by the name <code>succ</code>, for “successor,”
but David uses <code>add1</code>, so I will follow his lead),<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Unless you are going to study the untyped lambda calculus
<em>per se,</em> it’s not worth looking too deeply into why we
are using these specific functions. For our purposes, it’s
enough to know that they will work for the specific
example we will be evaulating with the evaluator that we
are going to build.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="info">
    
    Tags: <a title="All pages tagged 'compilers'." href="../tags/compilers.html" rel="tag">compilers</a>
    
</div>

        </div>
    </body>
</html>
