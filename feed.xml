<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Craig Stuntz's blog</title>
        <link>http://www.craigstuntz.com</link>
        <description><![CDATA[Craig Stuntz's blog]]></description>
        <atom:link href="http://www.craigstuntz.com/feed.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sat, 18 Jun 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>"Static vs. Dynamic" Is the Wrong Question for Working Programmers</title>
    <link>http://www.craigstuntz.com/posts/2016-06-18-static-vs-dynamic-wrong-question.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 18, 2016
    
</div>

<p>It’s common to ask, <em>“Is there evidence that programmers write safer code or are more productive when using a static or a dynamic language?”</em> It’s also common to write really terrible blog post answers to this question. I’m not going to link to examples, but let’s just say that general comparisons of “mainstream dynamic language A” with “mainstream static language B” don’t give a lot of insight into the broader question.</p>
<p>Programmers who say they prefer static or dynamic languages are <a href="https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/rdl04meijer.pdf">often interested in specific language features</a> rather than static or dynamic type systems, <em>per se.</em></p>
<p>Yet <a href="http://rundis.github.io/blog/2016/type_confused.html">reasonable people do want to know the answer</a>. Can we shed more light on the topic?</p>
<h2 id="science-cannot-give-us-a-definitive-answer-yet">Science Cannot Give Us a Definitive answer – Yet!</h2>
<p>Well-designed, peer reviewed research on human interaction with programming languages is <a href="https://jyx.jyu.fi/dspace/handle/123456789/47698">uncommon</a>. Static typing is <a href="https://www.quorumlanguage.com/evidence/evidence.pdf">better studied than most other PL features</a> but <a href="http://danluu.com/empirical-pl/">tends to examine very specific claims with fairly small effects</a>. Good studies which do exist at all, narrow as their findings might be, are <a href="2016-06-17-Andreas-Stefik-on-PL-Human-Factors.html">generally not reproduced by anyone</a>. There is <a href="http://www.cs.cmu.edu/~NatProg/programminglanguageusability/">an effort to fix this</a>, but for now any argument claiming a “scientific” answer to this question is suspect.</p>
<h2 id="there-arent-two-distinct-buckets-of-languages-named-static-and-dynamic">There Aren’t Two Distinct Buckets of Languages Named Static and Dynamic</h2>
<p>To be honest, I don’t think this question is answerable. In part this is because, increasingly, I think <strong>the notion of a strict distinction between static and dynamic languages is less than helpful</strong>. From the point of view of the working programmer, it confuses a number of different and important ways that both languages and tooling can vary.</p>
<p>Why? Ask yourself these questions:</p>
<h3 id="what-is-a-statically-typed-language">What Is a Statically Typed Language?</h3>
<p>Is Elm a statically typed language? Is Java a statically typed language?</p>
<ul>
<li><a href="http://elm-lang.org/blog/compilers-as-assistants">Elm’s type system acts as a coach</a> to help the programmer complete her work, but doesn’t really affect performance.</li>
<li>Java’s type system is a <a href="http://openjdk.java.net/jeps/286">verbose</a> impediment to code readers and writers, but <a href="http://cr.openjdk.java.net/~jrose/values/values-0.html">improves performance</a> by, for example, supporting many different primitive numeric types.</li>
</ul>
<p>Elm’s type system is substantially more powerful than Java’s, and eliminates entire classes of bugs which plague Java applications such as dereferencing null pointers and inexhaustive <code>switch</code> blocks.</p>
<p>If both languages are called “statically typed” and yet the two languages’ type systems do such different things, then how much value is there in lumping them into the same specific bucket?</p>
<p>Indeed, even the <a href="https://www.cl.cam.ac.uk/~srk31/research/papers/kell14in-author-version.pdf">word “type” itself is used in multiple, not entirely compatible senses</a> in computer science.</p>
<p>Tomas Petricek <a href="http://tomasp.net/blog/2015/against-types/">argues</a>:</p>
<blockquote>
<p>Rather than seeking the elusive definition of what is a type (which does not exist), I believe that we should look for innovative ways to think about and work with types that do not require an exact formal definition.</p>
</blockquote>
<h3 id="what-is-a-dynamic-language">What Is a Dynamic Language?</h3>
<p>Is Erlang a statically typed language? Many would say no, but what if I run <a href="http://erlang.org/doc/man/dialyzer.html">Dialyzer</a> first? Sure, I’m not getting the runtime performance benefits static typing can bring, but if types are inferred statically at build time and can fail the build, then I’m getting at least some help from static typing. So in this case the distinction between statically and dynamically typed has more to do with the tooling I might be using than the language itself. That’s interesting!</p>
<p>You can even <a href="https://github.com/frenchy64/ambrosebs.com/blob/gh-pages/talks/dynamic%20inference%20boston%20pi%202016.pdf">infer static types from unit tests instead of code itself</a>!</p>
<h3 id="whatever-static-and-dynamic-are-production-languages-often-have-both">Whatever “Static” and “Dynamic” Are, Production Languages Often Have Both</h3>
<p>C# has <code>dynamic</code>. Racket has <a href="https://docs.racket-lang.org/ts-guide/">Typed Racket</a>. Java has reflection. Clojure has <code>core.typed</code>.</p>
<p>Statically typed languages typically check certain types of errors at compile time and other types of errors at runtime.<sup>1</sup> Which types of errors are checked when varies by programming language. For example, Idris can statically prove that a program does not divide by zero, whereas C# cannot.</p>
<h3 id="well-ok-but-surely-there-must-be-a-formal-distinction-right">Well, OK, But Surely There Must Be a <em>Formal</em> Distinction, Right?</h3>
<p>Less so than you might think.</p>
<blockquote>
<p>Terms like “dynamically typed” are arguably misnomers and should probably be replaced by “dynamically checked,” but the usage is standard.<br/> – Benjamin C. Pierce, <em>Types and Programming Languages</em><sup>2</sup></p>
</blockquote>
<blockquote>
<p>Thus we see that the canonical untyped language, <strong>Λ</strong> [the untyped lambda calculus], which by dint of terminology stands in opposition to typed languages, turns out to be but a typed language after all. Rather than eliminating types, an untyped language consolidates an infinite collection of types into a single recursive type. Doing so renders static type checking trivial, at the cost of incurring dynamic overhead to coerce values to and from the recursive type.<br/> - Robert Harper, <em>Practical Foundations for Programming Languages</em><sup>3</sup></p>
</blockquote>
<p>One can consider a “dynamic language” as a language which has fewer statically checked types (namely, one) than a “static language.”</p>
<h2 id="what-does-static-typing-really-do">What Does Static Typing Really Do?</h2>
<p>Given some programming language, you can imagine “static typing” as a feature (or, more properly, a family of features) the language designer could add to an otherwise untyped or dynamic language which <strong>might</strong> deliver one or more of the following benefits:</p>
<ul>
<li>Proof that certain kinds of dynamic errors are impossible<sup>4</sup></li>
<li>Automatic and machine verified documentation</li>
<li>Improved runtime performance</li>
<li>Better tooling support</li>
</ul>
<p>It <strong>might</strong> also have one or more of the following drawbacks</p>
<ul>
<li>Increased verbosity or <a href="http://tratt.net/laurie/blog/entries/another_non_argument_in_type_systems.html">reduced expressiveness</a></li>
<li>Rejection of otherwise correct programs<sup>5</sup></li>
<li>Slower programmer iteration (possibly lengthy compile/run cycles)</li>
<li>A need for the developer to learn “static typing” language feature (through she still must understand types to some degree regardless)</li>
</ul>
<p>However, every single one of these benefits and drawbacks could also come from adding a different feature (distinct from “static typing”) to the language.</p>
<p>For example, “proof that certain kinds of dynamic errors are impossible” could come via model checking or formal verification. “Increased verbosity” is hardly limited to “static languages”; most “dynamic languages” are more verbose than SML or Haskell.</p>
<p>Instead of asking, “Should the whole world use a ‘statically typed’ language?” we could ask “In which cases would it make sense to write formal proofs of (at least some parts of) our programs?”</p>
<h2 id="if-static-vs.dynamic-is-the-wrong-question-then-what-is-the-right-question">If “Static vs. Dynamic” Is the Wrong Question, Then What Is the Right Question?</h2>
<p>If you’re a working programmer, then the right question is:</p>
<blockquote>
<p><strong>How can my languages and tooling help me be a better programmer?</strong></p>
</blockquote>
<p>Follow-up questions might be:</p>
<ul>
<li>If I care about verification of correctness properties above and beyond what I can do with simple tests, what are my choices, in terms of language features and tooling?</li>
<li>What are the properties which are difficult or impossible to verify?</li>
<li>Do the features and tooling of the language steer you towards great solutions to problems, provide you little guidance, or get in your way? Does the answer vary depending on which kind of problem?</li>
<li>What compromises does the language I’m using now make?</li>
<li>Can I use tools to fill in some of the shortcomings?</li>
<li>How do other languages and systems address my pain points?</li>
<li>Given some correct program I want to be the output of my process, how do I arrive at that program? Do I start by writing a specification (possibly in the form of types), or by writing tests, or by writing code, or a mix of these?</li>
</ul>
<p>These are difficult questions, because you can’t really answer them without experience with diverse languages, programming communities, and ecosystems. Zealots need not apply, but be kind to excited newbies!</p>
<p>Importantly, programming is still in its infancy. We are still discovering new methods of designing code. We must keep an open mind, because programmers 50 years from now will laugh at whatever we choose. Today, you can design your code using top-down, bottom-up, test-first, <a href="https://www.manning.com/books/type-driven-development-with-idris">type-driven</a>, or a multitude of other techniques. The design methodologies of the next decade probably haven’t been invented yet.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
<a href="https://twitter.com/raichoo"><span class="citation">@raichoo</span></a> <a href="https://twitter.com/kamatsu8"><span class="citation">@kamatsu8</span></a> let's have some imagination about where languages and tools might go if we let go of how current tools trade things off
</p>
— Edwin Brady (<span class="citation">@edwinbrady</span>) <a href="https://twitter.com/edwinbrady/status/743865720912609280">June 17, 2016</a>
</blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
<h5 id="notes">Notes</h5>
<p><sup>1</sup> Harper, Robert, <a href="http://www.cs.cmu.edu/~rwh/pfpl.html"><em>Practical Foundations for Programming Languages</em></a>, 2nd Edition, §6.3</p>
<p><sup>2</sup> Pierce, Benjamin C. <a href="https://www.cis.upenn.edu/~bcpierce/tapl/"><em>Types and Programming Languages</em></a>, p. 2</p>
<p><sup>3</sup> Harper, §21.4</p>
<p><sup>4</sup> Harper, §6</p>
<p><sup>5</sup> Rémy, Didier, <a href="http://gallium.inria.fr/~remy/mpri/cours1.pdf"><em>Type systems for programming languages</em></a>, p. 29</p>

<div class="info">
    
    Tags: <a href="/tags/programming%20languages.html">programming languages</a>
    
</div>
]]></description>
    <pubDate>Sat, 18 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://www.craigstuntz.com/posts/2016-06-18-static-vs-dynamic-wrong-question.html</guid>
    <dc:creator>Craig Stuntz</dc:creator>
</item>
<item>
    <title>Andreas Stefik on Programming Language Human Factors Research</title>
    <link>http://www.craigstuntz.com/posts/2016-06-17-Andreas-Stefik-on-PL-Human-Factors.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 17, 2016
    
</div>

<p><a href="https://www.functionalgeekery.com/episode-55-andreas-stefik/">This interview</a> with <a href="http://web.cs.unlv.edu/stefika/">Andreas Stefik</a> on empirical studies of human productivity with PL features is fascinating. In short: There aren’t many.</p>
<p>Very few randomized, controlled experiments in the field have ever been performed. <a href="https://jyx.jyu.fi/dspace/handle/123456789/47698">This 2015 thesis</a> found only 22!</p>
<p>Much if not most PL human factors research is <a href="http://www.dictionary.com/browse/anecdata">anecdata</a>. Even the few randomized, controlled experiments which have been performed have never been reproduced.</p>
<p>CS folks who have ever looked down their noses at social sciences for soft research standards should be mortified.</p>
<p>Never take blog posts or tweets claiming: “&lt;study&gt; found &lt;author’s pet PL feature&gt; boosts productivity by &lt;x&gt;” at face value. Conclusive, reproduced results on such a thing would be unprecedented in CS research.</p>

<div class="info">
    
    Tags: <a href="/tags/Andreas%20Stefik.html">Andreas Stefik</a>, <a href="/tags/programming%20languages.html">programming languages</a>
    
</div>
]]></description>
    <pubDate>Fri, 17 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://www.craigstuntz.com/posts/2016-06-17-Andreas-Stefik-on-PL-Human-Factors.html</guid>
    <dc:creator>Craig Stuntz</dc:creator>
</item>
<item>
    <title>Hosting a Hakyll Blog On GitHub With a Custom Domain</title>
    <link>http://www.craigstuntz.com/posts/2016-06-14-hakyll.html</link>
    <description><![CDATA[<div class="info">
    Posted on June 14, 2016
    
</div>

<ol style="list-style-type: decimal">
<li>Create a <a href="https://pages.github.com/">GitHub user page</a>. Follow the directions there to create a “Hello world” site. Don’t proceed until that works.</li>
<li>Register a domain.</li>
<li><a href="https://help.github.com/articles/setting-up-your-pages-site-repository/">Point your domain at your GitHub user pages site</a>. It may take 3+ hours before your domain propagates. Don’t continue until this works.</li>
<li>Install <a href="http://www.haskellstack.org">stack</a></li>
<li>Install hakyll via <a href="https://jaspervdj.be/hakyll/tutorials/01-installation.html"><code>stack install hakyll</code></a></li>
<li>Follow <a href="https://jaspervdj.be/hakyll/tutorials/github-pages-tutorial.html">this tutorial</a>. <em>However!</em> You already have a <code>master</code> branch. That’s OK. But you do want to have a <code>CNAME</code> file (see step 3 in this list) in your <code>develop</code> branch. Ensure your site looks good before proceeding.</li>
<li>You might want to look at some <a href="http://katychuang.com/hakyll-cssgarden/gallery/">sample themes</a>.</li>
<li>If you want code syntax highlighting, you need some <a href="https://www.jdreaver.com/posts/2014-06-22-math-programming-blog-hakyll.html">additional CSS</a>. A list of supported languages can be found in the <a href="https://github.com/jgm/highlighting-kate/tree/master/xml">highlighting-kate</a> source code.</li>
<li>You might also want an <a href="https://thibaud.dauce.fr/posts/2015-11-15-rss-feed-with-hakyll.html">RSS feed</a>.</li>
<li>You might also want <a href="http://javran.github.io/posts/2014-03-01-add-tags-to-your-hakyll-blog.html">tags</a>.</li>
</ol>

<div class="info">
    
    Tags: <a href="/tags/Hakyll.html">Hakyll</a>, <a href="/tags/GitHub.html">GitHub</a>
    
</div>
]]></description>
    <pubDate>Tue, 14 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://www.craigstuntz.com/posts/2016-06-14-hakyll.html</guid>
    <dc:creator>Craig Stuntz</dc:creator>
</item>
<item>
    <title>Designing for Problems Too Big to Test</title>
    <link>http://www.craigstuntz.com/posts/2015-12-23-Designing-for-Problems-Too-Big-to-Test.html</link>
    <description><![CDATA[<div class="info">
    Posted on December 23, 2015
    
</div>

<p>In this post, I will show an example of where using unit testing as a design methodology does not work, and how to produce a design for correct code anyway. There is no single design methodology which works for all problems, so it’s useful to have a variety of tools at your disposal.</p>
<p>This post is my contribution to the <a href="https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/">2015 F# Advent Calendar</a>.</p>
<p>I’m implementing a compiler for a tiny language without use of external libraries for things like parsing and code generation. The idea is to produce a minimal example of a purely functional compiler. This is an ongoing project, and some parts are further along than others, but you can see the source code as I work, and it does produce working EXEs today.</p>
<p>Designing a compiler is harder than many problems in programming, because they do something difficult: A compiler must be able to accept any string and either produce an equivalent program or explain clearly to a human being why this is string is not a valid program. And there are a lot of possible strings!</p>
<p>Designing a compiler is also easier than many problems in programming, because there exist formal methods for solving many of the harder sub-problems in the design. You can think of “formal methods,” here, as recipes for a solution, but very special recipes which guarantee that you’ll touch all possible cases in the problem space.</p>
<h3 id="design-methodologies">Design Methodologies</h3>
<p>Over the years, programmers have used a number of different methodologies when approaching program design. These include:</p>
<ul>
<li><strong>The Big Ball of Mud.</strong> Arguably the most common methodology, this involves just poking at the problem until things seem to work for the most common case, maybe.</li>
<li><strong>Big Design Up Front.</strong> In this methodology, a full specification for the implementation of the system is developed before coding begins. Many people consider this obsolete or, at best, wildly inefficient.</li>
<li><strong>Test Driven Design.</strong> I’m going to distinguish this from test driven development, because tests are useful both as a methodology for program design and for implementing a program design. In practice, people tend to combine these. As a design methodology, the general idea is that you start with either high or low level simple cases, and continue working until a design evolves. Some people divide this into sub-schools of test driven design. Despite its ubiquity, few defend the big ball of mud as a design practice. Big design up front is widely ridiculed. That leaves TDD as the most prevalent design methodology that people are willing to publicly defend. Unfortunately, testing, while useful, is fundamentally limited.</li>
</ul>
<blockquote>
<p>“…program testing can be a very effective way to show the presence of bugs, but is hopelessly inadequate for showing their absence.” Edsger Dijkstra</p>
</blockquote>
<p>In cases where “the happy path” is far more prevalent than “edge cases,” this might not seem to be a show-stopping limitation, and test driven design works OK in many cases.</p>
<h3 id="there-are-no-edge-cases-in-programming-languages">There Are No Edge Cases In Programming Languages</h3>
<p>As noted above, a compiler must be able to accept any string and either produce an equivalent program or explain clearly to a human being why this is string is not a valid program. A compiler designer cannot predict the valid programs people may write, nor the errors they may create.</p>
<p>For example, let’s consider <a href="https://en.wikipedia.org/wiki/Duff%27s_device">Duff’s Device</a>. It’s safe to presume that Brian Kernighan and Dennis Ritchie did not have this in mind when they designed the C programming language. For the uninitiated, Duff’s Device nests a while loop inside of a switch statement:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">send(to, from, count)
<span class="dt">register</span> <span class="dt">short</span> *to, *from;
<span class="dt">register</span> count;
{
    <span class="dt">register</span> n = (count + <span class="dv">7</span>) / <span class="dv">8</span>;
    <span class="kw">switch</span> (count % <span class="dv">8</span> ) {
    <span class="kw">case</span> <span class="dv">0</span>: <span class="kw">do</span> { *to = *from++;
    <span class="kw">case</span> <span class="dv">7</span>:      *to = *from++;
    <span class="kw">case</span> <span class="dv">6</span>:      *to = *from++;
    <span class="kw">case</span> <span class="dv">5</span>:      *to = *from++;
    <span class="kw">case</span> <span class="dv">4</span>:      *to = *from++;
    <span class="kw">case</span> <span class="dv">3</span>:      *to = *from++;
    <span class="kw">case</span> <span class="dv">2</span>:      *to = *from++;
    <span class="kw">case</span> <span class="dv">1</span>:      *to = *from++;
            } <span class="kw">while</span> (--n &gt; <span class="dv">0</span>);
    }
}</code></pre></div>
<p>This is unreadable to the point that it borders on obfuscation, but is legal C, per the specification, and does perform a useful optimization on a particular case. I bring it up because, as a language implementer, I think it drives home the point that there is no possibility of creating (anywhere near) all of the possible unit tests for all of the possible ways someone might choose to use your language.</p>
<h3 id="different-tasks-different-design-methodologies">Different Tasks, Different Design Methodologies</h3>
<p>In many programming tasks, the number of “happy path” cases are similar to the number of edge and error cases. At least within the same order of magnitude. In these cases it’s probably possible to exhaustively test the system, even if people don’t usually bother to do so.</p>
<p>For other tasks, however, the number of “edge cases” is uncountably large. I gave a programming language example above, but there are others, such as designing an API for a cloud service. In these cases, we need a design methodology which gives us some assurance that our design will work with cases that we did not and could not possibly produce tests for, because real-world use cases will vastly outnumber our test cases.</p>
<h3 id="formal-methods">Formal Methods</h3>
<p>The solution to this problem is to break the problem space into a countable number of conditions. This is only effective if those countable conditions represent all possible states in the problem space. For example, for a programming language, we divide the task of compilation into small phases such as lexing, parsing, etc., and within each phase we use a formalism which guarantees that we cover the entire possible range of conditions within that phase.</p>
<p>This will make more sense if I give an example.</p>
<h3 id="lexing-and-regular-expressions">Lexing and Regular Expressions</h3>
<p>In many compilers, the first phase of compilation is lexing, where the string representing the program source code is split into tokens. The token list will be passed to the parser, which attempts to match them up with the grammar of the programming language. As a practical example, consider the following expression from a Lisp-like language, which increments the number 1, resulting in the value 2.</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(inc <span class="dv">1</span>)</code></pre></div>
<p>Lexing divides this source code into a stream of tokens, like this:</p>
<pre><code>LeftParenthesis
Identifier &quot;inc&quot;
LiteralInt 1
RightParenthesis</code></pre>
<p>These tokens will be consumed by the parser to produce and abstract syntax tree, type checked, optimized, etc., but let’s just look at lexing for now.</p>
<p>Substrings of the input source code are mapped to tokens using regular expressions. Not <a href="http://www.regular-expressions.info/quickstart.html">the PCRE type with zillions of features</a> you might be familiar with, but <a href="https://en.wikipedia.org/wiki/Lexical_grammar">a far simpler version</a> with only a few rules. The lexical grammar for this language looks something like this:</p>
<div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp">leftParenthesis  = <span class="ch">&#39;(&#39;</span>
rightParenthesis = <span class="ch">&#39;)&#39;</span>
letter           = <span class="ch">&#39;A&#39;</span> | <span class="ch">&#39;B&#39;</span> | <span class="ch">&#39;C&#39;</span> | …
digit            = <span class="ch">&#39;0&#39;</span> | <span class="ch">&#39;1&#39;</span> | <span class="ch">&#39;2&#39;</span> | …
number           = (<span class="ch">&#39;+&#39;</span>digit|<span class="ch">&#39;-&#39;</span>digit|digit) digit*
alphanumeric     = letter | number
//<span class="co"> …</span></code></pre></div>
<p>You don’t use <code>System.Text.RegularExpressions.Regex</code> for this; it’s slow, and has features you won’t need.</p>
<p>How can we guarantee that we can tokenize any possible string? We don’t need to; as long as we explicitly handle the case of strings we can’t tokenize, we’re covered. I do this by having an extra token type for unrecognized characters. These are eventually mapped into errors the user sees.</p>
<p>How can we guarantee that we can tokenize any string representing a valid program without seeing an unrecognizable character? Because the parser is designed around a formalism (a context free grammar) which maps lexemes to abstract syntax trees, and the only valid programs are those which can be constructed from repeated applications of the production rules in the parser’s grammar. We have changed the scope of the problem from “any possible string” to “any possible sequence of lexemes.”</p>
<p>Right away we have a big win in the number of test cases. Any “character” in a string could be one of 2^16 UTF-16 code points, but the number of possible lexemes is considerably smaller. A real language would have <a href="https://github.com/whitequark/parser/blob/master/lib/parser/lexer.rl">maybe 10 times more</a>, but that’s still better than testing an input of any possible Unicode code point:</p>
<div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><span class="kw">type</span> Lexeme =
    | LeftParenthesis
    | RightParenthesis
    | Identifier    <span class="kw">of</span> <span class="dt">string</span>
    | LiteralInt    <span class="kw">of</span> <span class="dt">int</span>
    | LiteralString <span class="kw">of</span> <span class="dt">string</span>
    | Unrecognized  <span class="kw">of</span> <span class="dt">char</span></code></pre></div>
<p>We can test the lexer in isolation with a much smaller number of test cases.</p>
<p>The example I gave was a very simple expression, but real-world programs obviously contain more complicated expressions. Also, real-world code is often invalid and must be rejected by the compiler. Some coding errors cannot be detected until further on in the compilation pipeline, but there are possible errors at the lexing stage. For example, in my language, identifiers must begin with a letter, so the expression</p>
<div class="sourceCode"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp">(| <span class="dv">1</span>)</code></pre></div>
<p>…maps to:</p>
<div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp">LeftParenthesis
Unrecognized <span class="ch">&#39;|&#39;</span>
LiteralInt <span class="dv">1</span>
RightParenthesis</code></pre></div>
<p>Importantly, we should be able to examine any character of a real-world string, and map it into one of these types. The <code>Unrecognized</code> type serves as a kind of fall through for characters which do not fit into the types in the union.</p>
<p>F#’s exhaustiveness checking ensures that we cannot forget to handle a particular case even if we add additional lexemes to the language specification later. As a simple example, consider this pretty print function which takes a list of lexemes and produces a string similar to the originally parsed source code:</p>
<div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><span class="kw">let</span> <span class="kw">private</span> prettyPrintLexeme = <span class="kw">function</span>
| LeftParenthesis          -&gt; <span class="st">&quot;(&quot;</span>
| RightParenthesis         -&gt; <span class="st">&quot;)&quot;</span>
| Identifier    identifier -&gt; identifier
| LiteralInt    num        -&gt; num.ToString()
| LiteralString str        -&gt; sprintf <span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">%s</span><span class="ch">\&quot;</span><span class="st">&quot;</span> str
| Unrecognized  ch         -&gt; ch.ToString()

<span class="kw">let</span> prettyPrint =
    List<span class="kw">.</span>map prettyPrintLexeme
    &gt;&gt; String<span class="kw">.</span>concat <span class="st">&quot; &quot;</span></code></pre></div>
<p>If we were to, after the fact, add an additional type of lexeme, but forgot to modify the <code>prettyPrint</code> function, we would receive a compiler warning since the function would no longer be exhaustive.</p>
<h3 id="the-rest-of-the-pipeline">The Rest of the Pipeline</h3>
<p>What about parsing, type checking, and the rest of the compilation pipeline? Formalisms exist for those, as well.</p>
<table>
<thead>
<tr class="header">
<th align="left">Compilation phase</th>
<th align="left">Formalism</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Parsing</td>
<td align="left">Context free grammar</td>
</tr>
<tr class="even">
<td align="left">Optimization</td>
<td align="left">Algebra</td>
</tr>
<tr class="odd">
<td align="left">Type checking</td>
<td align="left">Logical inference rules</td>
</tr>
<tr class="even">
<td align="left">Code generation</td>
<td align="left">Denotational semantics</td>
</tr>
</tbody>
</table>
<h3 id="isnt-this-just-big-design-up-front">Isn’t This Just Big Design Up Front?</h3>
<p>The idea of basing your implementation design around in an exhaustive specification might sound like a big design up front, but there is an important difference. The formalisms used in implementing a compiler are “off the shelf.” Nobody has to sit down and create them, because they have been refined over decades of compiler implementations. You simply need to know that they exist.</p>
<p>If “formal methods” sounds too snobby for your taste, you can simply call this “programming with proven recipes.”</p>
<p>And of this downside of this methodology is that it becomes big design up front in those cases when there is not an off the shelf formalism available for your use. That’s OK! The important thing is to know when these formalisms exist in how to use them, when necessary.</p>
<p>The <a href="https://github.com/craigstuntz/TinyLanguage">full source code for this post</a> is available.</p>

<div class="info">
    
    Tags: <a href="/tags/F%23.html">F#</a>, <a href="/tags/compilers.html">compilers</a>, <a href="/tags/testing.html">testing</a>, <a href="/tags/formal%20methods.html">formal methods</a>
    
</div>
]]></description>
    <pubDate>Wed, 23 Dec 2015 00:00:00 UT</pubDate>
    <guid>http://www.craigstuntz.com/posts/2015-12-23-Designing-for-Problems-Too-Big-to-Test.html</guid>
    <dc:creator>Craig Stuntz</dc:creator>
</item>
<item>
    <title>Troubleshooting Entity Framework Connection Strings</title>
    <link>http://www.craigstuntz.com/posts/2010-08-13-troubleshooting-entity-framework-connection-strings.html</link>
    <description><![CDATA[<div class="info">
    Posted on August 13, 2010
    
</div>

<p>In an application which uses the Entity Framework, you may see the following error at runtime:</p>
<blockquote>
<p>MetadataException: Unable to load the specified metadata resource</p>
</blockquote>
<p>The cause of this error is a missing or malformed Entity Framework connection string. In particular, the cause of this error is the <code>metadata</code> parameter of the connection string. Let’s examine this more closely.</p>
<h2 id="which-config-file">Which Config File?</h2>
<p>Before you begin troubleshooting, make sure you are looking at the correct file.</p>
<p>Connection strings are loaded from the configuration file for the executing assembly, which may not be the assembly which contains your Entity Framework model. So if you have a data assembly containing an Entity Framework model and a web assembly containing a web application which references the data assembly, then the Entity Framework connection string needs to be in the <code>Web.config</code> file for the web assembly. The data assembly can have its own connection string, if you like (this is convenient, as it will be used by the Entity Framework designer), but it will not be used by the web application at runtime.</p>
<h2 id="metadata">Metadata</h2>
<p><a href="https://msdn.microsoft.com/en-us/library/cc716756.aspx">MSDN documents EF connection strings generally</a>. But the cause of the error above is specifically the <code>metadata</code> parameter. This parameter tells the Entity Framework where to find your EDMX at runtime. When your application is compiled, the EDMX is split into three parts: CSDL, MSL, and SSDL. For the purposes of this post, you don’t need to think about what they mean right now; it’s enough to know that you need all three of them at runtime.</p>
<p>The EDMX can be supplied to the application as embedded resources or files on disk. The default is embedded resources, so we’ll focus on that case.</p>
<p>The <code>metadata</code> parameter for an application with an Entity Framework model called <code>Model.edmx</code> in an assembly called <code>Simple Mvc.Data.dll</code> might look like this:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;connectionStrings&gt;</span>
	<span class="kw">&lt;add</span><span class="ot"> name=</span><span class="st">&quot;MyEntities&quot;</span><span class="ot"> connectionString=</span><span class="st">&quot;metadata=</span>
<span class="st">            res://Simple Mvc.Data.dll/Model.csdl|</span>
<span class="st">            res://Simple Mvc.Data.dll/Model.ssdl|</span>
<span class="st">            res://Simple Mvc.Data.dll/Model.msl;provider= </span><span class="er">&lt;</span><span class="st">!-- ... --&gt;</span></code></pre></div>
<p>So you can see there is one reference for each of the three parts of the EDMX that we need at runtime. They all work in the same way, so let’s examine just the first more closely. The CSDL reference looks like this:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml">res://Simple Mvc.Data.dll/Model.csdl</code></pre></div>
<p>It specifies three things:</p>
<ol style="list-style-type: decimal">
<li>We’re loading the CSDL from a resource. That’s the <code>res://</code> part.</li>
<li>The name of the assembly which contains the resource, <code>Simple Mvc.Data.dll</code>. If your assembly is strong named, you can specify a strong name, in all its verbose glory, here.</li>
<li>The name of the resource itself, <code>Model.csdl</code>. <em>Do not confuse this with the EDMX or model name.</em> In this case they happen to be the same, except for the extension, but <em>that’s not always true!</em></li>
</ol>
<p>Let’s examine #2 and 3 more closely.</p>
<h2 id="assembly-name">Assembly name</h2>
<p>It’s really common to omit the assembly name in a connect string, and use * instead, like this:</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;connectionStrings&gt;</span>
	<span class="kw">&lt;add</span><span class="ot"> name=</span><span class="st">&quot;MyEntities&quot;</span><span class="ot"> connectionString=</span><span class="st">&quot;metadata=</span>
<span class="st">            res://*/Model.csdl|</span>
<span class="st">            res://*/Model.ssdl|</span>
<span class="st">            res://*/Model.msl;provider= </span><span class="er">&lt;</span><span class="st">!-- ... --&gt;</span></code></pre></div>
<p>This means that instead of loading the resource from one specific assembly, the EF will scan all loaded assemblies at runtime. Two obvious downsides to this are that it takes a bit of time to do this, and the assembly might not be loaded yet. The second case is one reason you might get the error at the start of this post. So specifying the assembly explicitly is always a good idea, I think.</p>
<h2 id="resource-names">Resource names</h2>
<p>Remember how I said that the resource name isn’t necessarily the same as the model name? Here’s a real-life example of that. I opened one of our production assemblies in Reflector, and found this:</p>
<p><img src="/images/Vertex_data_ef_resources.png" alt="picture of resources with names like Vertex.data.bin.Model.Model.csdl" /></p>
<p>There’s actually a good reason that those resources have such bizarre names, but it’s a digression and not relevant to this post. The point is that after you’re sure the assembly name is right, the next step in solving the error at the top of this post is to double-check the resource names.</p>
<p>A simpler resource name will look like this:</p>
<p><img src="/images/Simple_MVC_resources.png" alt="picture of resources with names like Model.csdl" /></p>
<p>Remember the “simpler” <code>metadata</code> where I used <code>*</code> instead of the assembly name? You can go even simpler. This metadata, perhaps surprisingly, actually works (with caveats):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;connectionStrings&gt;</span>
	<span class="kw">&lt;add</span><span class="ot"> name=</span><span class="st">&quot;MyEntities&quot;</span><span class="ot"> connectionString=</span><span class="st">&quot;metadata=</span>
<span class="st">            res://*/;provider= </span><span class="er">&lt;</span><span class="st">!-- ... --&gt;</span></code></pre></div>
<p>This is the “throw everything against the wall and see what sticks” approach to a connect string. It will probably fail if your resources don’t happen to have the same name as your model, or if the assembly doesn’t happen to be loaded. But it (in simpler cases, anyway) frees the programmer from having to think about what any of this stuff means, so it’s a popular solution.</p>

<div class="info">
    
    Tags: <a href="/tags/C%23.html">C#</a>, <a href="/tags/connection%20strings.html">connection strings</a>, <a href="/tags/entity%20framework.html">entity framework</a>
    
</div>
]]></description>
    <pubDate>Fri, 13 Aug 2010 00:00:00 UT</pubDate>
    <guid>http://www.craigstuntz.com/posts/2010-08-13-troubleshooting-entity-framework-connection-strings.html</guid>
    <dc:creator>Craig Stuntz</dc:creator>
</item>

    </channel>
</rss>
